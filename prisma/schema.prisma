// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

model Group {
  id           String        @id
  name         String
  information  String?       @db.Text
  currency     String        @default("$")
  currencyCode String?
  participants Participant[]
  expenses     Expense[]
  gifts        Gift[]
  activities   Activity[]
  createdAt    DateTime      @default(now())
}

model Participant {
  id              String           @id
  name            String
  group           Group            @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId         String
  expensesPaidBy  Expense[]
  expensesPaidFor ExpensePaidFor[]
  giftsFor        Gift[]           @relation("GiftRecipient")
  giftsPaidFor    GiftPaidFor[]
  votes           Vote[]
  isActive        Boolean          @default(true)
}

model Category {
  id       Int       @id @default(autoincrement())
  grouping String
  name     String
  Expense  Expense[]
  Gift     Gift[]
}

model Expense {
  id               String            @id
  group            Group             @relation(fields: [groupId], references: [id], onDelete: Cascade)
  expenseDate      DateTime          @default(dbgenerated("CURRENT_DATE")) @db.Date
  title            String
  category         Category?         @relation(fields: [categoryId], references: [id])
  categoryId       Int               @default(0)
  amount           Int
  originalAmount   Int?
  originalCurrency String?
  conversionRate   Decimal?
  paidBy           Participant       @relation(fields: [paidById], references: [id], onDelete: Cascade)
  paidById         String
  paidFor          ExpensePaidFor[]
  groupId          String
  isReimbursement  Boolean           @default(false)
  splitMode        SplitMode         @default(EVENLY)
  createdAt        DateTime          @default(now())
  documents        ExpenseDocument[]
  notes            String?

  recurrenceRule         RecurrenceRule?       @default(NONE)
  recurringExpenseLink   RecurringExpenseLink?
  recurringExpenseLinkId String?
}

model ExpenseDocument {
  id        String   @id
  url       String
  width     Int
  height    Int
  Expense   Expense? @relation(fields: [expenseId], references: [id])
  expenseId String?
}

enum SplitMode {
  EVENLY
  BY_SHARES
  BY_PERCENTAGE
  BY_AMOUNT
}

model RecurringExpenseLink {
  id                    String  @id
  groupId               String
  currentFrameExpense   Expense @relation(fields: [currentFrameExpenseId], references: [id], onDelete: Cascade)
  currentFrameExpenseId String  @unique

  // Note: We do not want to link to the next expense because once it is created, it should be 
  // treated as it's own independent entity. This means that if a user wants to delete an Expense
  // and any prior related recurring expenses, they'll need to delete them one by one.
  nextExpenseCreatedAt DateTime?
  nextExpenseDate      DateTime

  @@index([groupId])
  @@index([groupId, nextExpenseCreatedAt, nextExpenseDate(sort: Desc)])
}

enum RecurrenceRule {
  NONE
  DAILY
  WEEKLY
  MONTHLY
}

model ExpensePaidFor {
  expense       Expense     @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  expenseId     String
  participantId String
  shares        Int         @default(1)

  @@id([expenseId, participantId])
}

model Activity {
  id            String       @id
  group         Group        @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId       String
  time          DateTime     @default(now())
  activityType  ActivityType
  participantId String?
  expenseId     String?
  data          String?
}

enum ActivityType {
  UPDATE_GROUP
  CREATE_EXPENSE
  UPDATE_EXPENSE
  DELETE_EXPENSE
  CREATE_GIFT
  UPDATE_GIFT
  DELETE_GIFT
  VOTE_GIFT
  OPT_IN_GIFT
  OPT_OUT_GIFT
}

model Gift {
  id          String         @id
  group       Group          @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  title       String
  description String?        @db.Text
  category    Category?      @relation(fields: [categoryId], references: [id])
  categoryId  Int            @default(0)
  amount      Int
  recipient   Participant    @relation("GiftRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  recipientId String
  paidFor     GiftPaidFor[]
  splitMode   SplitMode      @default(EVENLY)
  status      GiftStatus     @default(PLANNING)
  votes       Vote[]
  documents   GiftDocument[]
  notes       String?
  createdAt   DateTime       @default(now())

  @@index([groupId])
  @@index([recipientId])
}

model GiftDocument {
  id     String  @id
  url    String
  width  Int
  height Int
  Gift   Gift?   @relation(fields: [giftId], references: [id])
  giftId String?
}

enum GiftStatus {
  PLANNING
  BUYING
  BOUGHT
  COMPLETED
}

model GiftPaidFor {
  gift            Gift        @relation(fields: [giftId], references: [id], onDelete: Cascade)
  participant     Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  giftId          String
  participantId   String
  shares          Int         @default(1)
  isParticipating Boolean     @default(true)

  @@id([giftId, participantId])
}

model Vote {
  id            String      @id
  gift          Gift        @relation(fields: [giftId], references: [id], onDelete: Cascade)
  giftId        String
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  participantId String
  vote          VoteType
  createdAt     DateTime    @default(now())

  @@unique([giftId, participantId])
  @@index([giftId])
}

enum VoteType {
  UPVOTE
  DOWNVOTE
  ABSTAIN
}
